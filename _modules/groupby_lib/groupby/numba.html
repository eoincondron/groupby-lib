

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>groupby_lib.groupby.numba &mdash; groupby-lib 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            groupby-lib
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">groupby-lib</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">groupby_lib.groupby.numba</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for groupby_lib.groupby.numba</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">inspect</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">reduce</span><span class="p">,</span> <span class="n">wraps</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inspect</span><span class="w"> </span><span class="kn">import</span> <span class="n">signature</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numba</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nb</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">polars</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pl</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pyarrow</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pa</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numba.typed</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span> <span class="k">as</span> <span class="n">NumbaList</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..</span><span class="w"> </span><span class="kn">import</span> <span class="n">nanops</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..util</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">NumbaReductionOps</span><span class="p">,</span>
    <span class="n">_cast_timestamps_to_ints</span><span class="p">,</span>
    <span class="n">_null_value_for_numpy_type</span><span class="p">,</span>
    <span class="n">_scalar_func_decorator</span><span class="p">,</span>
    <span class="n">_val_to_numpy</span><span class="p">,</span>
    <span class="n">check_data_inputs_aligned</span><span class="p">,</span>
    <span class="n">is_null</span><span class="p">,</span>
    <span class="n">parallel_map</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># ===== Array Preparation Methods =====</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_build_target_for_groupby</span><span class="p">(</span><span class="n">np_type</span><span class="p">,</span> <span class="n">operation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">operation</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="s2">&quot;nancount&quot;</span><span class="p">):</span>
        <span class="c1"># for counts, the target is redundant as we collect the counts in a separate array</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">target</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np_type</span>
    <span class="k">if</span> <span class="s2">&quot;sum&quot;</span> <span class="ow">in</span> <span class="n">operation</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np_type</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;iub&quot;</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;uint64&quot;</span> <span class="k">if</span> <span class="n">np_type</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;u&quot;</span> <span class="k">else</span> <span class="s2">&quot;int64&quot;</span>
        <span class="n">initial_value</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">initial_value</span> <span class="o">=</span> <span class="n">_null_value_for_numpy_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>

    <span class="n">target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">initial_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">target</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_chunk_groupby_args</span><span class="p">(</span>
    <span class="n">n_chunks</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">reduce_func_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits groupby arguments into chunks for parallel or chunked processing.</span>

<span class="sd">    This function partitions the input arrays (`group_key`, `values`, and `mask`) into `n_chunks`</span>
<span class="sd">    and prepares argument sets for chunked groupby-reduce operations. It supports both single</span>
<span class="sd">    array and list-of-arrays for `values`, ensuring alignment with `group_key`. The resulting</span>
<span class="sd">    arguments are suitable for use with the `_group_by_reduce` function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_chunks : int</span>
<span class="sd">        The number of chunks to split the data into.</span>
<span class="sd">    group_key : np.ndarray</span>
<span class="sd">        Array of group labels, used to group the data.</span>
<span class="sd">    values : list of np.ndarray, np.ndarray, or None</span>
<span class="sd">        The data values to be grouped and reduced. Can be a single array, a list of arrays,</span>
<span class="sd">        or None if not required.</span>
<span class="sd">    ngroups: int</span>
<span class="sd">        The number of distinct groups</span>
<span class="sd">    reduce_func_name : str</span>
<span class="sd">        The name of reduction function to apply to each group.</span>
<span class="sd">    mask : np.ndarray, optional</span>
<span class="sd">        Optional boolean mask to filter the data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    chunked_args : list</span>
<span class="sd">        A list of `BoundArguments` objects, each containing the arguments for a chunked</span>
<span class="sd">        groupby-reduce operation.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the total length of `values` does not match the length of `group_key` when</span>
<span class="sd">        `values` is a list.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is intended for internal use to facilitate chunked or parallel groupby</span>
<span class="sd">    operations, especially when using Numba or similar parallelization tools.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;n_chunks&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">NumbaList</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;ui&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
            <span class="p">),</span> <span class="s2">&quot;Fancy indexing with chunked args is not allowed&quot;</span>
        <span class="n">chunked_args</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">kwargs</span> <span class="o">|</span> <span class="n">chunk</span>
            <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">_chunk_args_for_chunked_values</span><span class="p">(</span><span class="n">group_key</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="k">elif</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">chunked_args</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">kwargs</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">chunk</span><span class="p">)</span> <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">n_chunks</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">chunked_args</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">kwargs</span> <span class="o">|</span> <span class="n">chunk</span>
            <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">_chunk_args_for_unchunked_values</span><span class="p">(</span><span class="n">group_key</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">n_chunks</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="k">return</span> <span class="p">[</span>
        <span class="n">signature</span><span class="p">(</span><span class="n">_apply_group_method_single_chunk</span><span class="p">)</span><span class="o">.</span><span class="n">bind_partial</span><span class="p">(</span><span class="o">**</span><span class="n">chunk</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">chunked_args</span>
    <span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_chunk_args_for_chunked_values</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">group_key</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Length of group_key must match total length of all arrays in values&quot;</span>
        <span class="p">)</span>
    <span class="n">splits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">lengths</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">key_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">group_key</span><span class="p">,</span> <span class="n">splits</span><span class="p">)</span>
    <span class="n">mask_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">key_list</span><span class="p">)</span> <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">splits</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="nb">dict</span><span class="p">(</span>
            <span class="n">group_key</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">v</span><span class="p">,</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">m</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">key_list</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">mask_list</span><span class="p">)</span>
    <span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_chunk_args_for_unchunked_values</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">n_chunks</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">key_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">group_key</span><span class="p">,</span> <span class="n">n_chunks</span><span class="p">)</span>
    <span class="n">value_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">n_chunks</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">group_key</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">key_list</span><span class="p">,</span> <span class="n">value_list</span><span class="p">)]</span>


<span class="c1"># ===== Row Selection Methods =====</span>


<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_find_nth</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">ngroups</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ngroups</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="n">masked</span> <span class="o">=</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group_key</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group_key</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rng</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">group_key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">masked</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">seen</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">seen</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">out</span>


<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_find_first_or_last_n</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">forward</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">ngroups</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ngroups</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="n">masked</span> <span class="o">=</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">forward</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group_key</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group_key</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rng</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">group_key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">masked</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">continue</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">seen</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">seen</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">forward</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">out</span>


<div class="viewcode-block" id="find_first_n">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.find_first_n">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_first_n</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the first n indices for each group in group_key.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group_key : ArrayType1D</span>
<span class="sd">        1D array defining the groups.</span>
<span class="sd">    ngroups : int</span>
<span class="sd">        The number of unique groups in group_key.</span>
<span class="sd">    n : int</span>
<span class="sd">        The number of indices to find for each group.</span>
<span class="sd">    mask : Optional[ArrayType1D]</span>
<span class="sd">        A boolean mask to filter the elements before finding indices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        An array of shape (ngroups, n) with the first n indices for each group.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_find_first_or_last_n</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">(),</span> <span class="n">forward</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>



<div class="viewcode-block" id="find_last_n">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.find_last_n">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_last_n</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the last n indices for each group in group_key.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group_key : ArrayType1D</span>
<span class="sd">        1D array defining the groups.</span>
<span class="sd">    ngroups : int</span>
<span class="sd">        The number of unique groups in group_key.</span>
<span class="sd">    n : int</span>
<span class="sd">        The number of indices to find for each group.</span>
<span class="sd">    mask : Optional[ArrayType1D]</span>
<span class="sd">        A boolean mask to filter the elements before finding indices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        An array of shape (ngroups, n) with the last n indices for each group.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_find_first_or_last_n</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">(),</span> <span class="n">forward</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>



<span class="c1"># ===== Group Aggregation Methods =====</span>


<div class="viewcode-block" id="ScalarFuncs">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.ScalarFuncs">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ScalarFuncs</span><span class="p">:</span>

<div class="viewcode-block" id="ScalarFuncs.sum">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.ScalarFuncs.sum">[docs]</a>
    <span class="nd">@_scalar_func_decorator</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="n">cur_sum</span><span class="p">,</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">count</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cur_sum</span> <span class="o">+</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="ScalarFuncs.nansum">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.ScalarFuncs.nansum">[docs]</a>
    <span class="nd">@_scalar_func_decorator</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nansum</span><span class="p">(</span><span class="n">cur_sum</span><span class="p">,</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_null</span><span class="p">(</span><span class="n">next_val</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cur_sum</span><span class="p">,</span> <span class="n">count</span>
        <span class="k">elif</span> <span class="n">count</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cur_sum</span> <span class="o">+</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="ScalarFuncs.nansum_squares">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.ScalarFuncs.nansum_squares">[docs]</a>
    <span class="nd">@_scalar_func_decorator</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nansum_squares</span><span class="p">(</span><span class="n">cur_sum</span><span class="p">,</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_null</span><span class="p">(</span><span class="n">next_val</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cur_sum</span><span class="p">,</span> <span class="n">count</span>
        <span class="k">elif</span> <span class="n">count</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cur_sum</span> <span class="o">+</span> <span class="n">next_val</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">next_val</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="ScalarFuncs.max">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.ScalarFuncs.max">[docs]</a>
    <span class="nd">@_scalar_func_decorator</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">cur_max</span><span class="p">,</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_null</span><span class="p">(</span><span class="n">next_val</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span>
        <span class="k">elif</span> <span class="n">count</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">next_val</span> <span class="o">&gt;</span> <span class="n">cur_max</span><span class="p">:</span>
                <span class="n">cur_max</span> <span class="o">=</span> <span class="n">next_val</span>
            <span class="k">return</span> <span class="n">cur_max</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="ScalarFuncs.nanmax">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.ScalarFuncs.nanmax">[docs]</a>
    <span class="nd">@_scalar_func_decorator</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nanmax</span><span class="p">(</span><span class="n">cur_max</span><span class="p">,</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_null</span><span class="p">(</span><span class="n">next_val</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cur_max</span><span class="p">,</span> <span class="n">count</span>
        <span class="k">elif</span> <span class="n">count</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">next_val</span> <span class="o">&gt;</span> <span class="n">cur_max</span><span class="p">:</span>
                <span class="n">cur_max</span> <span class="o">=</span> <span class="n">next_val</span>
            <span class="k">return</span> <span class="n">cur_max</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="ScalarFuncs.min">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.ScalarFuncs.min">[docs]</a>
    <span class="nd">@_scalar_func_decorator</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="n">cur_max</span><span class="p">,</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_null</span><span class="p">(</span><span class="n">next_val</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span>
        <span class="k">elif</span> <span class="n">count</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">next_val</span> <span class="o">&lt;</span> <span class="n">cur_max</span><span class="p">:</span>
                <span class="n">cur_max</span> <span class="o">=</span> <span class="n">next_val</span>
            <span class="k">return</span> <span class="n">cur_max</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="ScalarFuncs.nanmin">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.ScalarFuncs.nanmin">[docs]</a>
    <span class="nd">@_scalar_func_decorator</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nanmin</span><span class="p">(</span><span class="n">cur_min</span><span class="p">,</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_null</span><span class="p">(</span><span class="n">next_val</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cur_min</span><span class="p">,</span> <span class="n">count</span>
        <span class="k">elif</span> <span class="n">count</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">next_val</span> <span class="o">&lt;</span> <span class="n">cur_min</span><span class="p">:</span>
                <span class="n">cur_min</span> <span class="o">=</span> <span class="n">next_val</span>
            <span class="k">return</span> <span class="n">cur_min</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="ScalarFuncs.nancount">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.ScalarFuncs.nancount">[docs]</a>
    <span class="nd">@_scalar_func_decorator</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nancount</span><span class="p">(</span><span class="n">cur_count</span><span class="p">,</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_null</span><span class="p">(</span><span class="n">next_val</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">count</span><span class="p">,</span> <span class="n">count</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">new_count</span><span class="p">,</span> <span class="n">new_count</span></div>


<div class="viewcode-block" id="ScalarFuncs.count">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.ScalarFuncs.count">[docs]</a>
    <span class="nd">@_scalar_func_decorator</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="n">cur_size</span><span class="p">,</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="n">new_count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">new_count</span><span class="p">,</span> <span class="n">new_count</span></div>


<div class="viewcode-block" id="ScalarFuncs.first">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.ScalarFuncs.first">[docs]</a>
    <span class="nd">@_scalar_func_decorator</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">first</span><span class="p">(</span><span class="n">cur_first</span><span class="p">,</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_null</span><span class="p">(</span><span class="n">next_val</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cur_first</span><span class="p">,</span> <span class="n">count</span>
        <span class="k">elif</span> <span class="n">count</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cur_first</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="ScalarFuncs.last">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.ScalarFuncs.last">[docs]</a>
    <span class="nd">@_scalar_func_decorator</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">last</span><span class="p">(</span><span class="n">cur_last</span><span class="p">,</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_null</span><span class="p">(</span><span class="n">next_val</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cur_last</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">next_val</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span></div>
</div>



<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_group_by_reduce</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">reduce_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
    <span class="n">indexer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">check_in_bounds</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Core numba-compiled groupby reduction function with optional indexing.</span>

<span class="sd">    This is the low-level function that performs the actual groupby reduction operation.</span>
<span class="sd">    It iterates through the data and applies a reduction function to accumulate values</span>
<span class="sd">    within each group. Supports optional indexing for masked operations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group_key : np.ndarray</span>
<span class="sd">        1D integer array where each element indicates the group index for that row.</span>
<span class="sd">        Negative values indicate null/missing groups and are skipped.</span>
<span class="sd">    values : np.ndarray</span>
<span class="sd">        1D array of values to be aggregated. Must be same length as group_key.</span>
<span class="sd">    target : np.ndarray</span>
<span class="sd">        Pre-allocated array to store the reduction results for each group.</span>
<span class="sd">        Length must equal the number of unique groups.</span>
<span class="sd">    reduce_func : Callable</span>
<span class="sd">        Numba-compiled reduction function from ScalarFuncs (e.g., ScalarFuncs.nansum).</span>
<span class="sd">        Must accept (current_value, new_value, count) and return (updated_value, updated_count).</span>
<span class="sd">    indexer : np.ndarray, optional</span>
<span class="sd">        Array of indices to process. If None, processes all elements sequentially.</span>
<span class="sd">        Used for boolean mask operations converted to integer indices.</span>
<span class="sd">    check_in_bounds : bool, default True</span>
<span class="sd">        Whether to validate that indexer values are within bounds of the arrays.</span>
<span class="sd">        Set to False when indexer is guaranteed to be valid (e.g., from nonzero()).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[np.ndarray, np.ndarray]</span>
<span class="sd">        - target: Array of aggregated values for each group</span>
<span class="sd">        - count: Array of counts for each group indicating how many values were processed</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function is JIT-compiled with numba for optimal performance</span>
<span class="sd">    - Negative group keys are treated as null/missing and skipped</span>
<span class="sd">    - The target array is modified in-place</span>
<span class="sd">    - Thread-safe when used with different target arrays</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">indexer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group_key</span><span class="p">)):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">group_key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">target</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">count</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_func</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">count</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">group_key</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indexer</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">check_in_bounds</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">n_rows</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Indexer </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> is out of bounds for array of length </span><span class="si">{</span><span class="n">n_rows</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">group_key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">target</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">count</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_func</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">count</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">target</span><span class="p">,</span> <span class="n">count</span>


<span class="nd">@check_data_inputs_aligned</span><span class="p">(</span><span class="s2">&quot;group_key&quot;</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_apply_group_method_single_chunk</span><span class="p">(</span>
    <span class="n">reduce_func_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a single reduction function to a chunk of grouped data.</span>

<span class="sd">    This function serves as a high-level wrapper around _group_by_reduce that handles</span>
<span class="sd">    input conversion, mask processing, and target array preparation. It&#39;s designed to</span>
<span class="sd">    work with a single chunk of data and is commonly used in parallel processing scenarios.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reduce_func_name : str</span>
<span class="sd">        Name of the reduction function from ScalarFuncs to apply (e.g., &#39;nansum&#39;, &#39;nanmean&#39;).</span>
<span class="sd">    group_key : ArrayType1D</span>
<span class="sd">        Array of group labels for each value. Can be numpy array, pandas Series, etc.</span>
<span class="sd">    values : ArrayType1D</span>
<span class="sd">        Array of values to be aggregated. Must be same length as group_key.</span>
<span class="sd">    ngroups : int</span>
<span class="sd">        Total number of unique groups expected in the complete dataset.</span>
<span class="sd">        Used for pre-allocating the target array.</span>
<span class="sd">    mask : Optional[ArrayType1D], optional</span>
<span class="sd">        Boolean mask or integer indices to filter which elements to process.</span>
<span class="sd">        If boolean, True values indicate elements to include.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[np.ndarray, np.ndarray]</span>
<span class="sd">        - target: Array of aggregated values for each group (length=ngroups)</span>
<span class="sd">        - count: Array of counts for each group indicating number of values processed</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Converts input arrays to numpy format automatically</span>
<span class="sd">    - Boolean masks are converted to integer indices using nonzero()</span>
<span class="sd">    - Target array is pre-allocated with appropriate dtype and initial values</span>
<span class="sd">    - Function signature is checked to ensure group_key and values are aligned</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from groupby_lib.groupby.numba import _apply_group_method_single_chunk</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; group_key = np.array([0, 1, 0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])</span>
<span class="sd">    &gt;&gt;&gt; target, count = _apply_group_method_single_chunk(</span>
<span class="sd">    ...     &#39;nansum&#39;, group_key, values, ngroups=3</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; print(target)  # [4.0, 6.0, 5.0]</span>
<span class="sd">    &gt;&gt;&gt; print(count)   # [2, 2, 1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">group_key</span> <span class="o">=</span> <span class="n">_val_to_numpy</span><span class="p">(</span><span class="n">group_key</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">group_key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mask must have the same length as group_key&quot;</span><span class="p">)</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">check_in_bounds</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="n">check_in_bounds</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">_build_target_for_groupby</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">reduce_func_name</span><span class="p">,</span> <span class="n">ngroups</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_group_by_reduce</span><span class="p">(</span>
        <span class="n">group_key</span><span class="o">=</span><span class="n">group_key</span><span class="p">,</span>
        <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
        <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
        <span class="n">indexer</span><span class="o">=</span><span class="n">indexer</span><span class="p">,</span>
        <span class="n">reduce_func</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">ScalarFuncs</span><span class="p">,</span> <span class="n">reduce_func_name</span><span class="p">),</span>
        <span class="n">check_in_bounds</span><span class="o">=</span><span class="n">check_in_bounds</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="reduce_array_pair">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.reduce_array_pair">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">reduce_array_pair</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">reducer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">counts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a reduction function element-wise to pairs of arrays using parallel processing.</span>

<span class="sd">    This function takes two arrays of equal length and applies a reduction function</span>
<span class="sd">    to each pair of corresponding elements. It&#39;s optimized for parallel execution</span>
<span class="sd">    using numba&#39;s prange for better performance on multi-core systems.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray</span>
<span class="sd">        First input array. Must have the same length as y.</span>
<span class="sd">    y : np.ndarray</span>
<span class="sd">        Second input array. Must have the same length as x.</span>
<span class="sd">    reducer : Callable</span>
<span class="sd">        Reduction function from ScalarFuncs (e.g., ScalarFuncs.nansum, ScalarFuncs.nanmax).</span>
<span class="sd">        Must accept (value1, value2, count) and return (result, updated_count).</span>
<span class="sd">        The count parameter is fixed at 1 for this function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Array of the same length as inputs containing the element-wise reduction results.</span>
<span class="sd">        Only the reduced values are returned (not the counts).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function is JIT-compiled with numba and runs in parallel using prange</span>
<span class="sd">    - Both input arrays must have the same length</span>
<span class="sd">    - The reducer function is called with count=1 for each pair</span>
<span class="sd">    - Used primarily for combining results from chunked parallel operations</span>
<span class="sd">    - The function assumes x contains accumulated values that will be combined with y</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from groupby_lib.groupby.numba import reduce_array_pair, ScalarFuncs</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([1.0, 3.0, 5.0])</span>
<span class="sd">    &gt;&gt;&gt; y = np.array([2.0, 4.0, 6.0])</span>
<span class="sd">    &gt;&gt;&gt; result = reduce_array_pair(x, y, ScalarFuncs.nansum)</span>
<span class="sd">    &gt;&gt;&gt; print(result)  # [3.0, 7.0, 11.0]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nb</span><span class="o">.</span><span class="n">prange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">counts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">reducer</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">out</span></div>



<div class="viewcode-block" id="combine_chunk_results_for_unfactorized_key">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.combine_chunk_results_for_unfactorized_key">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">combine_chunk_results_for_unfactorized_key</span><span class="p">(</span>
    <span class="n">reduce_func_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">labels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">counts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine chunk results for unfactorized (non-continuous integer) group keys.</span>

<span class="sd">    This function handles the case where group keys are not factorized (e.g., string</span>
<span class="sd">    labels, non-continuous integers). It creates a unified index from all chunk labels</span>
<span class="sd">    and combines the corresponding values using the specified reduction function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reduce_func_name : str</span>
<span class="sd">        Name of reduction function from ScalarFuncs (e.g., &quot;nansum&quot;, &quot;nanmax&quot;).</span>
<span class="sd">        Used to combine values across chunks for each group.</span>
<span class="sd">    chunks : List[np.ndarray]</span>
<span class="sd">        List of result arrays from each chunk, one per chunk processed.</span>
<span class="sd">        Each array contains the reduced values for groups present in that chunk.</span>
<span class="sd">    labels : List[np.ndarray]</span>
<span class="sd">        List of group label arrays corresponding to each chunk.</span>
<span class="sd">        These identify which groups are present in each chunk&#39;s results.</span>
<span class="sd">    counts : Optional[List[np.ndarray]], default None</span>
<span class="sd">        List of count arrays for each chunk, used for operations that need to</span>
<span class="sd">        track the number of observations per group. If None, counts are not tracked.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[pd.Series, pd.Series | None, pd.Index]</span>
<span class="sd">        combined : pd.Series</span>
<span class="sd">            Series with the combined results for all groups, indexed by group labels.</span>
<span class="sd">        combined_count : pd.Series | None</span>
<span class="sd">            Series with combined counts per group if counts were provided, None otherwise.</span>
<span class="sd">        all_labels : pd.Index</span>
<span class="sd">            Union of all group labels from all chunks.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Used when group keys are not factorized (e.g., string group names)</span>
<span class="sd">    - Creates a pandas Index union to handle non-overlapping groups across chunks</span>
<span class="sd">    - Uses reduce_array_pair to combine values for groups that appear in multiple chunks</span>
<span class="sd">    - More memory intensive than factorized key combination due to pandas operations</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from groupby_lib.groupby.numba import combine_chunk_results_for_unfactorized_key, ScalarFuncs</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; chunks = [np.array([10.0, 20.0]), np.array([30.0, 5.0])]</span>
<span class="sd">    &gt;&gt;&gt; labels = [np.array([&#39;A&#39;, &#39;B&#39;]), np.array([&#39;A&#39;, &#39;C&#39;])]</span>
<span class="sd">    &gt;&gt;&gt; combined, combined_count, all_labels = combine_chunk_results_for_unfactorized_key(</span>
<span class="sd">    ...     ScalarFuncs.nansum, chunks, labels, None</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; print(combined)  # A: 40.0, B: 20.0, C: 5.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_labels</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="o">.</span><span class="n">union</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">,</span> <span class="n">labels</span><span class="p">))</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">_build_target_for_groupby</span><span class="p">(</span>
        <span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">reduce_func_name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_labels</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">combined</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">all_labels</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">counts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
        <span class="n">combined_count</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">combined_count</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">all_labels</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">counts</span><span class="p">):</span>
        <span class="n">combined</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_array_pair</span><span class="p">(</span>
            <span class="n">combined</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ScalarFuncs</span><span class="p">,</span> <span class="n">reduce_func_name</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">combined_count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">combined_count</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">combined_count</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+</span> <span class="n">count</span>

    <span class="k">return</span> <span class="n">combined</span><span class="p">,</span> <span class="n">combined_count</span><span class="p">,</span> <span class="n">all_labels</span></div>



<div class="viewcode-block" id="combine_chunk_results_for_factorized_key">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.combine_chunk_results_for_factorized_key">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">combine_chunk_results_for_factorized_key</span><span class="p">(</span>
    <span class="n">reduce_func_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">counts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine chunk results for factorized (continuous integer) group keys.</span>

<span class="sd">    This function handles the case where group keys are factorized (0, 1, 2, ..., n-1).</span>
<span class="sd">    Since factorized keys have a known, continuous structure, this function can efficiently</span>
<span class="sd">    combine results by directly applying the reduction function element-wise across chunks.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reduce_func_name : str</span>
<span class="sd">        Name of reduction function from ScalarFuncs (e.g., &quot;nansum&quot;, &quot;nanmax&quot;).</span>
<span class="sd">        Used to combine values across chunks for each group position.</span>
<span class="sd">    chunks : List[np.ndarray]</span>
<span class="sd">        List of result arrays from each chunk, one per chunk processed.</span>
<span class="sd">        All arrays must have the same length (ngroups), with each position</span>
<span class="sd">        corresponding to the same group across all chunks.</span>
<span class="sd">    counts : Optional[List[np.ndarray]], default None</span>
<span class="sd">        List of count arrays for each chunk, used for operations that need to</span>
<span class="sd">        track the number of observations per group. If None, counts are not tracked.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[np.ndarray, np.ndarray | int]</span>
<span class="sd">        combined : np.ndarray</span>
<span class="sd">            Array with the combined results for all groups, with the same length as input chunks.</span>
<span class="sd">        combined_count : np.ndarray | int</span>
<span class="sd">            Combined counts per group if counts were provided, otherwise 0.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Used when group keys are factorized (continuous integers 0, 1, 2, ...)</span>
<span class="sd">    - More memory efficient than unfactorized key combination due to direct array operations</span>
<span class="sd">    - All chunks must have the same length since they represent the same groups</span>
<span class="sd">    - Uses reduce_array_pair sequentially to combine chunks pairwise</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from groupby_lib.groupby.numba import combine_chunk_results_for_factorized_key, ScalarFuncs</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; chunks = [np.array([10.0, 20.0, 30.0]), np.array([5.0, 15.0, 25.0])]</span>
<span class="sd">    &gt;&gt;&gt; combined, combined_count = combine_chunk_results_for_factorized_key(</span>
<span class="sd">    ...     ScalarFuncs.nansum, chunks, None</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; print(combined)  # [15.0, 35.0, 55.0]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">combined</span> <span class="o">=</span> <span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">counts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
        <span class="n">combined_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">combined_count</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="n">reduce_array_pair</span><span class="p">(</span>
            <span class="n">combined</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ScalarFuncs</span><span class="p">,</span> <span class="n">reduce_func_name</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">combined_count</span> <span class="o">=</span> <span class="n">combined_count</span> <span class="o">+</span> <span class="n">count</span>

    <span class="k">return</span> <span class="n">combined</span><span class="p">,</span> <span class="n">combined_count</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_group_func_wrap</span><span class="p">(</span>
    <span class="n">reduce_func_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">return_count</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies a reduction function to grouped data, supporting chunked arrays, optional masking, and multi-threading.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reduce_func_name : str</span>
<span class="sd">        Name of the reduction function to apply (e.g., &#39;sum&#39;, &#39;mean&#39;, &#39;count&#39;).</span>
<span class="sd">    group_key : ArrayType1D</span>
<span class="sd">        Array of group labels for each value.</span>
<span class="sd">    values : ArrayType1D</span>
<span class="sd">        Array of values to be reduced, possibly chunked.</span>
<span class="sd">    ngroups : int</span>
<span class="sd">        Number of unique groups.</span>
<span class="sd">    mask : Optional[ArrayType1D], optional</span>
<span class="sd">        Boolean, fancy index or slice mask to filter values and group keys before reduction.</span>
<span class="sd">    n_threads : int, default 1</span>
<span class="sd">        Number of threads to use for parallel processing. If 1, runs single-threaded.</span>
<span class="sd">    return_count : bool, default False</span>
<span class="sd">        If True, also returns the count of values per group.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : np.ndarray</span>
<span class="sd">        Array of reduced values per group.</span>
<span class="sd">    count : np.ndarray, optional</span>
<span class="sd">        Array of counts per group, returned if `return_count` is True.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Handles chunked arrays and fancy indexing.</span>
<span class="sd">    - Supports parallel processing for chunked data.</span>
<span class="sd">    - Preserves original dtype for datetime and timedelta types.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="c1"># slicing creates views at no cost</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">group_key</span> <span class="o">=</span> <span class="n">group_key</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">group_key</span> <span class="o">=</span> <span class="n">_val_to_numpy</span><span class="p">(</span><span class="n">group_key</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">_val_to_numpy</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">as_list</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">values_are_chunked</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>

    <span class="n">fancy_indexing</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">_val_to_numpy</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;ui&quot;</span><span class="p">:</span>
            <span class="n">fancy_indexing</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">values</span><span class="p">,</span> <span class="n">orig_types</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_cast_timestamps_to_ints</span><span class="p">,</span> <span class="n">values</span><span class="p">)))</span>
    <span class="n">orig_type</span> <span class="o">=</span> <span class="n">orig_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">reduce_func_name</span> <span class="o">==</span> <span class="s2">&quot;sum_squares&quot;</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">values_are_chunked</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fancy_indexing</span><span class="p">:</span>
            <span class="c1"># fancy indexer doesn&#39;t play nicely with chunking values</span>
            <span class="c1"># Unchunk the values and follow this path</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="n">values_are_chunked</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">group_key</span><span class="o">=</span><span class="n">group_key</span><span class="p">,</span>
        <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
        <span class="n">ngroups</span><span class="o">=</span><span class="n">ngroups</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
        <span class="n">reduce_func_name</span><span class="o">=</span><span class="n">reduce_func_name</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">counting</span> <span class="o">=</span> <span class="s2">&quot;count&quot;</span> <span class="ow">in</span> <span class="n">reduce_func_name</span>

    <span class="k">if</span> <span class="n">n_threads</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">values_are_chunked</span><span class="p">:</span>
        <span class="n">result</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">_apply_group_method_single_chunk</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">counting</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">count</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">chunked_args</span> <span class="o">=</span> <span class="n">_chunk_groupby_args</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">n_chunks</span><span class="o">=</span><span class="n">n_threads</span><span class="p">)</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="n">parallel_map</span><span class="p">(</span>
            <span class="n">_apply_group_method_single_chunk</span><span class="p">,</span> <span class="p">[</span><span class="n">args</span><span class="o">.</span><span class="n">args</span> <span class="k">for</span> <span class="n">args</span> <span class="ow">in</span> <span class="n">chunked_args</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">chunks</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">chunks</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">counting</span><span class="p">:</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="n">counts</span>

        <span class="n">result</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">combine_chunk_results_for_factorized_key</span><span class="p">(</span>
            <span class="s2">&quot;sum&quot;</span> <span class="k">if</span> <span class="n">counting</span> <span class="ow">or</span> <span class="s2">&quot;sum&quot;</span> <span class="ow">in</span> <span class="n">reduce_func_name</span> <span class="k">else</span> <span class="n">reduce_func_name</span><span class="p">,</span>
            <span class="n">chunks</span><span class="p">,</span>
            <span class="n">counts</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">orig_type</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;mM&quot;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">orig_type</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_count</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">count</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="group_size">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.group_size">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">group_size</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Count the number of elements in each group defined by group_key.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group_key : ArrayType1D</span>
<span class="sd">        1D array defining the groups.</span>
<span class="sd">    ngroups : int</span>
<span class="sd">        The number of unique groups in group_key.</span>
<span class="sd">    mask : Optional[ArrayType1D]</span>
<span class="sd">        A boolean mask to filter the elements before counting.</span>
<span class="sd">    n_threads : int</span>
<span class="sd">        Number of threads to use for parallel processing.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ArrayType1D</span>
<span class="sd">        An array with the count of elements in each group.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_group_func_wrap</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">group_key</span><span class="p">,</span> <span class="o">**</span><span class="nb">locals</span><span class="p">())</span></div>



<div class="viewcode-block" id="group_count">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.group_count">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">group_count</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">return_count</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Count the number of non-null values in each group.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group_key : ArrayType1D</span>
<span class="sd">        The array defining the groups.</span>
<span class="sd">    values : ArrayType1D</span>
<span class="sd">        The array of values to count.</span>
<span class="sd">    ngroups : int</span>
<span class="sd">        The number of unique groups in `group_key`.</span>
<span class="sd">    mask : Optional[ArrayType1D], default None</span>
<span class="sd">        A mask array to filter the values. If provided, only non-null values where the mask</span>
<span class="sd">        is True will be counted.</span>
<span class="sd">    n_threads : int, default 1</span>
<span class="sd">        The number of threads to use for parallel processing. If set to 1, the function will run in a single thread.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ArrayType1D</span>
<span class="sd">        An array of counts for each group, where the index corresponds to the group key.</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function counts the number of non-null values in each group defined by `group_key`.</span>
<span class="sd">    If a mask is provided, it will only count the values where the mask is True.</span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from groupby_lib.groupby.numba import group_count</span>
<span class="sd">    &gt;&gt;&gt; group_key = np.array([0, 1, 0, 1, 2, 2])</span>
<span class="sd">    &gt;&gt;&gt; values = np.array([1, 2, np.nan, 3, 4, np.nan, 5])</span>
<span class="sd">    &gt;&gt;&gt; ngroups = 3</span>
<span class="sd">    &gt;&gt;&gt; counts = group_count(group_key, values, ngroups)</span>
<span class="sd">    &gt;&gt;&gt; print(counts)</span>
<span class="sd">    [2 2 1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_group_func_wrap</span><span class="p">(</span><span class="s2">&quot;nancount&quot;</span><span class="p">,</span> <span class="o">**</span><span class="nb">locals</span><span class="p">())</span></div>



<div class="viewcode-block" id="group_sum">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.group_sum">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">group_sum</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">return_count</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;ui&quot;</span><span class="p">:</span>
        <span class="n">reduce_func_name</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">reduce_func_name</span> <span class="o">=</span> <span class="s2">&quot;nansum&quot;</span>
    <span class="k">return</span> <span class="n">_group_func_wrap</span><span class="p">(</span><span class="o">**</span><span class="nb">locals</span><span class="p">())</span></div>



<div class="viewcode-block" id="group_sum_squares">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.group_sum_squares">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">group_sum_squares</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">return_count</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">_group_func_wrap</span><span class="p">(</span><span class="n">reduce_func_name</span><span class="o">=</span><span class="s2">&quot;nansum_squares&quot;</span><span class="p">,</span> <span class="o">**</span><span class="nb">locals</span><span class="p">())</span></div>



<div class="viewcode-block" id="group_mean">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.group_mean">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">group_mean</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">return_count</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;return_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">sum_</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">_group_func_wrap</span><span class="p">(</span><span class="s2">&quot;nansum&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">sum_</span><span class="p">,</span> <span class="n">orig_type</span> <span class="o">=</span> <span class="n">_cast_timestamps_to_ints</span><span class="p">(</span><span class="n">sum_</span><span class="p">)</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">sum_</span> <span class="o">/</span> <span class="n">count</span>
    <span class="k">if</span> <span class="n">orig_type</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;mM&quot;</span><span class="p">:</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">orig_type</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="k">if</span> <span class="n">return_count</span> <span class="k">else</span> <span class="n">mean</span></div>



<div class="viewcode-block" id="group_min">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.group_min">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">group_min</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">return_count</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">_group_func_wrap</span><span class="p">(</span><span class="s2">&quot;nanmin&quot;</span><span class="p">,</span> <span class="o">**</span><span class="nb">locals</span><span class="p">())</span></div>



<div class="viewcode-block" id="group_max">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.group_max">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">group_max</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">return_count</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">_group_func_wrap</span><span class="p">(</span><span class="s2">&quot;nanmax&quot;</span><span class="p">,</span> <span class="o">**</span><span class="nb">locals</span><span class="p">())</span></div>



<div class="viewcode-block" id="group_first">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.group_first">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">group_first</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">return_count</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">_group_func_wrap</span><span class="p">(</span><span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="o">**</span><span class="nb">locals</span><span class="p">())</span></div>



<div class="viewcode-block" id="group_last">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.group_last">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">group_last</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">return_count</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">_group_func_wrap</span><span class="p">(</span><span class="s2">&quot;last&quot;</span><span class="p">,</span> <span class="o">**</span><span class="nb">locals</span><span class="p">())</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_wrap_numba</span><span class="p">(</span><span class="n">nb_func</span><span class="p">):</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">nb_func</span><span class="o">.</span><span class="n">py_func</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">bound_args</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">nb_func</span><span class="o">.</span><span class="n">py_func</span><span class="p">)</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bound_args</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">nb_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">wrapper</span><span class="o">.</span><span class="n">__nb_func__</span> <span class="o">=</span> <span class="n">nb_func</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<div class="viewcode-block" id="group_nearby_members">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.group_nearby_members">[docs]</a>
<span class="nd">@check_data_inputs_aligned</span><span class="p">(</span><span class="s2">&quot;group_key&quot;</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">)</span>
<span class="nd">@_wrap_numba</span>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">group_nearby_members</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">max_diff</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n_groups</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a vector of integers defining groups and an aligned numerical vector, values,</span>
<span class="sd">    generate subgroups where the differences between consecutive members of a group are below a threshold.</span>
<span class="sd">    For example, group events which are close in time and which belong to the same group defined by the group key.</span>

<span class="sd">    group_key: np.ndarray</span>
<span class="sd">        Vector defining the initial groups</span>
<span class="sd">    values:</span>
<span class="sd">        Array of numerical values used to determine closeness of the group members, e.g. an array of timestamps.</span>
<span class="sd">        Assumed to be monotonic non-decreasing.</span>
<span class="sd">    max_diff: float | int</span>
<span class="sd">        The threshold distance for forming a new sub-group</span>
<span class="sd">    n_groups: int</span>
<span class="sd">        The number of unique groups in group_key</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">group_counter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_groups</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">last_seen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_groups</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">group_tracker</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_groups</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group_key</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group_key</span><span class="p">)):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">group_key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">current_value</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">seen</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="n">seen</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">make_new_group</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">make_new_group</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">current_value</span> <span class="o">-</span> <span class="n">last_seen</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">max_diff</span>

        <span class="k">if</span> <span class="n">make_new_group</span><span class="p">:</span>
            <span class="n">group_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">group_tracker</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_counter</span>

        <span class="n">last_seen</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_value</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_tracker</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">out</span></div>



<span class="c1"># ===== Rolling Aggregation Methods =====</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_apply_rolling</span><span class="p">(</span>
    <span class="n">operation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">min_periods</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">allow_downcasting</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    General dispatcher for rolling operations that handles 1D vs 2D cases.</span>

<span class="sd">    This function dispatches to the appropriate 1D function or uses the 2D wrapper</span>
<span class="sd">    based on the dimensionality of the input values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    operation : str</span>
<span class="sd">        Name of the rolling operation (&#39;sum&#39;, &#39;mean&#39;, &#39;min&#39;, &#39;max&#39;)</span>
<span class="sd">    group_key : ArrayType1D</span>
<span class="sd">        1D array defining the groups</span>
<span class="sd">    values : ArrayType1D</span>
<span class="sd">        Values to aggregate.</span>
<span class="sd">    ngroups : int</span>
<span class="sd">        Number of unique groups in group_key</span>
<span class="sd">    window : int</span>
<span class="sd">        Size of the rolling window (constant across all groups)</span>
<span class="sd">    min_periods : Optional[int]</span>
<span class="sd">        Minimum number of non-null observations in window required to have a value</span>
<span class="sd">    mask : Optional[ArrayType1D]</span>
<span class="sd">        Boolean mask to filter elements</span>
<span class="sd">    n_threads : int, default 1</span>
<span class="sd">        Number of threads to use for parallel column processing (2D values only)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Rolling aggregation results with same shape as values</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If operation is not supported or values are not 1D/2D</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Map operation names to 1D functions</span>
    <span class="n">rolling_1d_funcs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;sum&quot;</span><span class="p">:</span> <span class="n">_rolling_sum_or_mean_1d</span><span class="p">,</span>
        <span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">_rolling_sum_or_mean_1d</span><span class="p">,</span>
        <span class="s2">&quot;min&quot;</span><span class="p">:</span> <span class="n">_rolling_max_or_min_1d</span><span class="p">,</span>
        <span class="s2">&quot;max&quot;</span><span class="p">:</span> <span class="n">_rolling_max_or_min_1d</span><span class="p">,</span>
        <span class="s2">&quot;shift&quot;</span><span class="p">:</span> <span class="n">_rolling_shift_or_diff_1d</span><span class="p">,</span>
        <span class="s2">&quot;diff&quot;</span><span class="p">:</span> <span class="n">_rolling_shift_or_diff_1d</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">operation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rolling_1d_funcs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported rolling operation: </span><span class="si">{</span><span class="n">operation</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Convert inputs to appropriate numpy arrays</span>
    <span class="n">group_key</span> <span class="o">=</span> <span class="n">_val_to_numpy</span><span class="p">(</span><span class="n">group_key</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">_val_to_numpy</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

    <span class="n">rolling_1d_func</span> <span class="o">=</span> <span class="n">rolling_1d_funcs</span><span class="p">[</span><span class="n">operation</span><span class="p">]</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">_val_to_numpy</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">as_list</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">values</span><span class="p">,</span> <span class="n">orig_dtypes</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_cast_timestamps_to_ints</span><span class="p">,</span> <span class="n">values</span><span class="p">)))</span>
    <span class="n">orig_dtype</span> <span class="o">=</span> <span class="n">orig_dtypes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">values_are_times</span> <span class="o">=</span> <span class="n">orig_dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;mM&quot;</span>

    <span class="n">null_value</span> <span class="o">=</span> <span class="n">_null_value_for_numpy_type</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">allow_downcasting</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">values_are_times</span><span class="p">:</span>
        <span class="n">null_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span> <span class="o">|</span> <span class="nb">locals</span><span class="p">()</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">signature</span><span class="p">(</span><span class="n">rolling_1d_func</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">}</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">rolling_1d_func</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">values_are_times</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;diff&quot;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;m8[ns]&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">orig_dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_rolling_sum_or_mean_1d</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">min_periods</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">null_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
    <span class="n">want_mean</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Core numba function for rolling sum on 1D values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group_key : np.ndarray</span>
<span class="sd">        1D array defining the groups</span>
<span class="sd">    values : np.ndarray</span>
<span class="sd">        1D array of values to aggregate</span>
<span class="sd">    ngroups : int</span>
<span class="sd">        Number of unique groups</span>
<span class="sd">    window : int</span>
<span class="sd">        Rolling window size (constant across all groups)</span>
<span class="sd">    mask : Optional[np.ndarray]</span>
<span class="sd">        Boolean mask to filter elements</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Rolling sums for each position</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">min_periods</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_periods</span> <span class="o">=</span> <span class="n">window</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group_key</span><span class="p">),</span> <span class="n">null_value</span><span class="p">)</span>
    <span class="n">masked</span> <span class="o">=</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="c1"># Track rolling sums and circular buffers for each group</span>
    <span class="n">group_sums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ngroups</span><span class="p">)</span>
    <span class="n">group_buffers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">ngroups</span><span class="p">,</span> <span class="n">window</span><span class="p">),</span> <span class="n">null_value</span><span class="p">)</span>
    <span class="n">group_positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ngroups</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="n">group_non_null</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ngroups</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="n">group_n_seen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ngroups</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">group_key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Skip null keys</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">masked</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="n">val_is_null</span> <span class="o">=</span> <span class="n">is_null</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="c1"># Get current position in circular buffer for this group</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">group_positions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="c1"># If buffer is full, subtract the value that will be replaced</span>
            <span class="n">group_full</span> <span class="o">=</span> <span class="n">group_n_seen</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">window</span>
            <span class="k">if</span> <span class="n">group_full</span><span class="p">:</span>
                <span class="n">old_val</span> <span class="o">=</span> <span class="n">group_buffers</span><span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_null</span><span class="p">(</span><span class="n">old_val</span><span class="p">):</span>
                    <span class="n">group_sums</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">-=</span> <span class="n">old_val</span>
                    <span class="n">group_non_null</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="c1"># Add new value</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">val_is_null</span><span class="p">:</span>
                <span class="n">group_non_null</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">group_sums</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val</span>

            <span class="n">group_buffers</span><span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

            <span class="c1"># Update position and count</span>
            <span class="n">group_positions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">window</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">group_full</span><span class="p">:</span>
                <span class="n">group_n_seen</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">group_non_null</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_periods</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">want_mean</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_sums</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">/</span> <span class="n">group_non_null</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_sums</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">out</span>


<div class="viewcode-block" id="rolling_sum">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.rolling_sum">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rolling_sum</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayType1D</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">min_periods</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">allow_downcasting</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate rolling sum within each group using optimized circular buffer approach.</span>

<span class="sd">    This function uses an optimized algorithm that maintains running sums and circular</span>
<span class="sd">    buffers for O(1) add/remove operations, making it much faster than naive</span>
<span class="sd">    implementations that recalculate sums for each window.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group_key : ArrayType1D</span>
<span class="sd">        1D array defining the groups</span>
<span class="sd">    values : ArrayType1D or np.ndarray</span>
<span class="sd">        Values to aggregate. Can be 1D or 2D (for multiple columns)</span>
<span class="sd">    ngroups : int</span>
<span class="sd">        Number of unique groups in group_key</span>
<span class="sd">    window : int</span>
<span class="sd">        Size of the rolling window (constant across all groups)</span>
<span class="sd">    mask : Optional[ArrayType1D]</span>
<span class="sd">        Boolean mask to filter elements</span>
<span class="sd">    n_threads : int, default 1</span>
<span class="sd">        Number of threads to use for parallel column processing (2D values only)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Rolling sums with same shape as values</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Window size is constant across all groups</span>
<span class="sd">    - Uses circular buffer with O(1) operations for optimal performance</span>
<span class="sd">    - Handles NaN values by skipping them in calculations</span>
<span class="sd">    - Supports both 1D and 2D (multi-column) input values</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from groupby_lib.groupby.numba import rolling_sum</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # 1D example</span>
<span class="sd">    &gt;&gt;&gt; group_key = np.array([0, 0, 0, 1, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; values = np.array([1, 2, 3, 4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; result = rolling_sum(group_key, values, ngroups=2, window=2)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    [1. 3. 5. 4. 9. 11.]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # 2D example (multiple columns)</span>
<span class="sd">    &gt;&gt;&gt; values_2d = np.array([[1, 10], [2, 20], [3, 30], [4, 40], [5, 50], [6, 60]])</span>
<span class="sd">    &gt;&gt;&gt; result_2d = rolling_sum(group_key, values_2d, ngroups=2, window=2)</span>
<span class="sd">    &gt;&gt;&gt; print(result_2d)</span>
<span class="sd">    [[  1.  10.]</span>
<span class="sd">     [  3.  30.]</span>
<span class="sd">     [  5.  50.]</span>
<span class="sd">     [  4.  40.]</span>
<span class="sd">     [  9.  90.]</span>
<span class="sd">     [ 11. 110.]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_apply_rolling</span><span class="p">(</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="n">want_mean</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="nb">locals</span><span class="p">())</span></div>



<div class="viewcode-block" id="rolling_mean">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.rolling_mean">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rolling_mean</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayType1D</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">min_periods</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">allow_downcasting</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate rolling mean within each group.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group_key : ArrayType1D</span>
<span class="sd">        1D array defining the groups</span>
<span class="sd">    values : ArrayType1D or np.ndarray</span>
<span class="sd">        Values to aggregate. Can be 1D or 2D (for multiple columns)</span>
<span class="sd">    ngroups : int</span>
<span class="sd">        Number of unique groups in group_key</span>
<span class="sd">    window : int</span>
<span class="sd">        Size of the rolling window</span>
<span class="sd">    mask : Optional[ArrayType1D]</span>
<span class="sd">        Boolean mask to filter elements</span>
<span class="sd">    n_threads : int, default 1</span>
<span class="sd">        Number of threads to use for parallel column processing (2D values only)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Rolling means with same shape as values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_apply_rolling</span><span class="p">(</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="n">want_mean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="nb">locals</span><span class="p">())</span></div>



<div class="viewcode-block" id="min_or_max_and_position">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.min_or_max_and_position">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">min_or_max_and_position</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">want_max</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">is_null</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">best</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">best_pos</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:],</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">want_max</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="n">best</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">want_max</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">best</span><span class="p">):</span>
            <span class="n">best</span> <span class="o">=</span> <span class="n">v</span>
            <span class="n">best_pos</span> <span class="o">=</span> <span class="n">j</span>

    <span class="k">return</span> <span class="n">best</span><span class="p">,</span> <span class="n">best_pos</span></div>



<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_rolling_max_or_min_1d</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">min_periods</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">null_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
    <span class="n">want_max</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Optimized core numba function for rolling max/min on 1D values.</span>

<span class="sd">    Uses position tracking to avoid scanning entire window on each update.</span>
<span class="sd">    Only recomputes min when the current minimum falls out of the window.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">min_periods</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_periods</span> <span class="o">=</span> <span class="n">window</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group_key</span><span class="p">),</span> <span class="n">null_value</span><span class="p">)</span>
    <span class="n">masked</span> <span class="o">=</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="n">want_min</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">want_max</span>

    <span class="c1"># Track rolling max/min and its position in circular buffers for each group</span>
    <span class="n">current_best</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">ngroups</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">want_max</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="n">pos_of_current_best</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ngroups</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="n">group_buffers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">ngroups</span><span class="p">,</span> <span class="n">window</span><span class="p">),</span> <span class="n">null_value</span><span class="p">)</span>
    <span class="n">group_buffer_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ngroups</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="n">group_non_null</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ngroups</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="n">group_n_seen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ngroups</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">group_key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Skip null keys</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">masked</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="n">val_is_null</span> <span class="o">=</span> <span class="n">is_null</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="c1"># Get current position in circular buffer for this group</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">group_buffer_pos</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">cur_best</span> <span class="o">=</span> <span class="n">current_best</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="n">need_recalc</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">pos_of_current_best</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">need_recalc</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">n_seen</span> <span class="o">=</span> <span class="n">group_n_seen</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">group_full</span> <span class="o">=</span> <span class="n">n_seen</span> <span class="o">&gt;=</span> <span class="n">window</span>
            <span class="k">if</span> <span class="n">group_full</span><span class="p">:</span>
                <span class="n">to_remove</span> <span class="o">=</span> <span class="n">group_buffers</span><span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_null</span><span class="p">(</span><span class="n">to_remove</span><span class="p">):</span>
                    <span class="n">group_non_null</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="n">group_buffers</span><span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="c1"># Add new value</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">val_is_null</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">group_non_null</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="ow">or</span> <span class="p">(</span><span class="n">want_max</span> <span class="ow">and</span> <span class="n">val</span> <span class="o">&gt;=</span> <span class="n">cur_best</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="p">(</span><span class="n">want_min</span> <span class="ow">and</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">cur_best</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">current_best</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                    <span class="n">pos_of_current_best</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span>
                    <span class="n">need_recalc</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">group_non_null</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">group_full</span> <span class="ow">and</span> <span class="n">need_recalc</span><span class="p">:</span>
                <span class="c1"># Recompute max from remaining window</span>
                <span class="n">window_vals</span> <span class="o">=</span> <span class="n">group_buffers</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">window_best</span><span class="p">,</span> <span class="n">pos_of_best</span> <span class="o">=</span> <span class="n">min_or_max_and_position</span><span class="p">(</span>
                    <span class="n">window_vals</span><span class="p">,</span> <span class="n">want_max</span>
                <span class="p">)</span>
                <span class="n">current_best</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">window_best</span>
                <span class="n">pos_of_current_best</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos_of_best</span> <span class="o">-</span> <span class="n">pos</span><span class="p">)</span> <span class="o">%</span> <span class="n">window</span>

            <span class="c1"># Update position and count</span>
            <span class="n">new_position</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">window</span>
            <span class="n">group_buffer_pos</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_position</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">group_full</span><span class="p">:</span>
                <span class="n">group_n_seen</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">group_non_null</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_periods</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_best</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">out</span>


<div class="viewcode-block" id="rolling_min">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.rolling_min">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rolling_min</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayType1D</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">min_periods</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">allow_downcasting</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate rolling minimum within each group.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group_key : ArrayType1D</span>
<span class="sd">        1D array defining the groups</span>
<span class="sd">    values : ArrayType1D or np.ndarray</span>
<span class="sd">        Values to aggregate. Can be 1D or 2D (for multiple columns)</span>
<span class="sd">    ngroups : int</span>
<span class="sd">        Number of unique groups in group_key</span>
<span class="sd">    window : int</span>
<span class="sd">        Size of the rolling window</span>
<span class="sd">    mask : Optional[ArrayType1D]</span>
<span class="sd">        Boolean mask to filter elements</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Rolling minimums with same shape as values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_apply_rolling</span><span class="p">(</span><span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="n">want_max</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="nb">locals</span><span class="p">())</span></div>



<div class="viewcode-block" id="rolling_max">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.rolling_max">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rolling_max</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayType1D</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">min_periods</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">allow_downcasting</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">n_threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate rolling maximum within each group.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group_key : ArrayType1D</span>
<span class="sd">        1D array defining the groups</span>
<span class="sd">    values : ArrayType1D or np.ndarray</span>
<span class="sd">        Values to aggregate. Can be 1D or 2D (for multiple columns)</span>
<span class="sd">    ngroups : int</span>
<span class="sd">        Number of unique groups in group_key</span>
<span class="sd">    window : int</span>
<span class="sd">        Size of the rolling window</span>
<span class="sd">    mask : Optional[ArrayType1D]</span>
<span class="sd">        Boolean mask to filter elements</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Rolling maximums with same shape as values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_apply_rolling</span><span class="p">(</span><span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="n">want_max</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="nb">locals</span><span class="p">())</span></div>



<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_rolling_shift_or_diff_1d</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">null_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
    <span class="n">want_shift</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Optimized core numba function for rolling max/min on 1D values.</span>

<span class="sd">    Uses position tracking to avoid scanning entire window on each update.</span>
<span class="sd">    Only recomputes min when the current minimum falls out of the window.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group_key</span><span class="p">),</span> <span class="n">null_value</span><span class="p">)</span>
    <span class="n">masked</span> <span class="o">=</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="c1"># Track rolling sums and circular buffers for each group</span>
    <span class="n">group_buffers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">ngroups</span><span class="p">,</span> <span class="n">window</span><span class="p">),</span> <span class="n">null_value</span><span class="p">)</span>
    <span class="n">group_buffer_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ngroups</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="n">group_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ngroups</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">group_key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Skip null keys</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">masked</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="c1"># Get current position in circular buffer for this group and add new val</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">group_buffer_pos</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">group_counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">window</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">want_shift</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_buffers</span><span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">-</span> <span class="n">group_buffers</span><span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">group_counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">group_buffers</span><span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="c1"># Update position</span>
            <span class="n">group_buffer_pos</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">window</span>

    <span class="k">return</span> <span class="n">out</span>


<div class="viewcode-block" id="rolling_shift">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.rolling_shift">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rolling_shift</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">allow_downcasting</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">_apply_rolling</span><span class="p">(</span><span class="s2">&quot;shift&quot;</span><span class="p">,</span> <span class="n">want_shift</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="nb">locals</span><span class="p">())</span></div>



<div class="viewcode-block" id="rolling_diff">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.rolling_diff">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rolling_diff</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">window</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">allow_downcasting</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">_apply_rolling</span><span class="p">(</span><span class="s2">&quot;diff&quot;</span><span class="p">,</span> <span class="n">want_shift</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="nb">locals</span><span class="p">())</span></div>



<span class="c1"># ================================</span>
<span class="c1"># Cumulative Aggregation Functions</span>
<span class="c1"># ================================</span>


<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_cumulative_reduce</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">reduce_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Core numba function for cumulative aggregations within groups.</span>

<span class="sd">    This function iterates through data and maintains running aggregated values</span>
<span class="sd">    for each group, outputting the cumulative result at each position.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group_key : np.ndarray</span>
<span class="sd">        1D array defining the groups</span>
<span class="sd">    values : np.ndarray</span>
<span class="sd">        1D array of values to aggregate</span>
<span class="sd">    reduce_func : callable</span>
<span class="sd">        Numba-compiled reduction function (e.g., NumbaReductionOps.sum)</span>
<span class="sd">    ngroups : int</span>
<span class="sd">        Number of unique groups in group_key</span>
<span class="sd">    mask : Optional[np.ndarray]</span>
<span class="sd">        Boolean mask to filter elements</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Cumulative aggregated values with same shape as input values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">masked</span> <span class="o">=</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="c1"># Track current state for each group</span>
    <span class="n">group_last_seen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">ngroups</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">group_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ngroups</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint32&quot;</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">has_null_key</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">group_key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">has_null_key</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">continue</span>

            <span class="n">last_seen</span> <span class="o">=</span> <span class="n">group_last_seen</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">masked</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="c1"># For masked values, pass through the current accumulator without updating</span>
                <span class="k">if</span> <span class="n">last_seen</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="n">last_seen</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">group_count</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_func</span><span class="p">(</span>
                <span class="n">target</span><span class="p">[</span><span class="n">last_seen</span><span class="p">],</span> <span class="n">val</span><span class="p">,</span> <span class="n">group_count</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">group_last_seen</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">target</span><span class="p">,</span> <span class="n">has_null_key</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_apply_cumulative</span><span class="p">(</span>
    <span class="n">operation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayType1D</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_na</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">use_py_func</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    General dispatcher for cumulative operations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    operation : str</span>
<span class="sd">        Name of the cumulative operation (&#39;sum&#39;, &#39;count&#39;, &#39;min&#39;, &#39;max&#39;)</span>
<span class="sd">    group_key : ArrayType1D</span>
<span class="sd">        1D array defining the groups</span>
<span class="sd">    values : ArrayType1D or None</span>
<span class="sd">        Values to aggregate. Can be None for count operations.</span>
<span class="sd">    ngroups : int</span>
<span class="sd">        Number of unique groups in group_key</span>
<span class="sd">    mask : Optional[ArrayType1D]</span>
<span class="sd">        Boolean mask to filter elements</span>
<span class="sd">    skip_na : bool, default True</span>
<span class="sd">        Whether to skip NaN values in aggregation</span>
<span class="sd">    use_py_func: bool</span>
<span class="sd">        Do not use the JIT-compiled function. For debugging purposes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Cumulative aggregation results with appropriate dtype</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If operation is not supported</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert inputs to appropriate numpy arrays</span>
    <span class="n">group_key</span> <span class="o">=</span> <span class="n">_val_to_numpy</span><span class="p">(</span><span class="n">group_key</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">_val_to_numpy</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

    <span class="c1"># Map operation names to reduction functions</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;nan&quot;</span> <span class="o">+</span> <span class="n">operation</span> <span class="k">if</span> <span class="n">skip_na</span> <span class="k">else</span> <span class="n">operation</span>
        <span class="n">reduce_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ScalarFuncs</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported cumulative operation: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;values cannot be None for operation &#39;</span><span class="si">{</span><span class="n">operation</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

    <span class="n">counting</span> <span class="o">=</span> <span class="s2">&quot;count&quot;</span> <span class="ow">in</span> <span class="n">operation</span>

    <span class="n">values</span> <span class="o">=</span> <span class="n">_val_to_numpy</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">as_list</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">values</span><span class="p">,</span> <span class="n">orig_dtypes</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_cast_timestamps_to_ints</span><span class="p">,</span> <span class="n">values</span><span class="p">)))</span>
    <span class="n">orig_dtype</span> <span class="o">=</span> <span class="n">orig_dtypes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">target</span> <span class="o">=</span> <span class="n">_build_target_for_groupby</span><span class="p">(</span>
        <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;sum&quot;</span> <span class="k">if</span> <span class="n">counting</span> <span class="k">else</span> <span class="n">operation</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">group_key</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">_cumulative_reduce</span><span class="o">.</span><span class="n">py_func</span> <span class="k">if</span> <span class="n">use_py_func</span> <span class="k">else</span> <span class="n">_cumulative_reduce</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">has_null_keys</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span>
        <span class="n">group_key</span><span class="o">=</span><span class="n">group_key</span><span class="p">,</span>
        <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
        <span class="n">reduce_func</span><span class="o">=</span><span class="n">reduce_func</span><span class="p">,</span>
        <span class="n">ngroups</span><span class="o">=</span><span class="n">ngroups</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
        <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">has_null_keys</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;count&quot;</span> <span class="ow">in</span> <span class="n">operation</span><span class="p">:</span>
            <span class="n">na_rep</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">na_rep</span> <span class="o">=</span> <span class="n">_null_value_for_numpy_type</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">group_key</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">na_rep</span>

    <span class="k">elif</span> <span class="n">orig_dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;mM&quot;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">orig_dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="cumsum">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.cumsum">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cumsum</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_na</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate cumulative sum within each group.</span>

<span class="sd">    For each group defined by group_key, this function returns the running sum</span>
<span class="sd">    of values up to each position. The cumulative sum resets at the beginning</span>
<span class="sd">    of each new group.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group_key : ArrayType1D</span>
<span class="sd">        1D array defining the groups</span>
<span class="sd">    values : ArrayType1D</span>
<span class="sd">        Values to calculate cumulative sum for</span>
<span class="sd">    ngroups : int</span>
<span class="sd">        Number of unique groups in group_key</span>
<span class="sd">    mask : Optional[ArrayType1D]</span>
<span class="sd">        Boolean mask to filter elements before aggregation</span>
<span class="sd">    skip_na : bool, default True</span>
<span class="sd">        Whether to skip NaN values in the sum calculation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Cumulative sums with same shape as input values</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from groupby_lib.groupby.numba import cumsum</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Basic usage</span>
<span class="sd">    &gt;&gt;&gt; group_key = np.array([0, 0, 0, 1, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; values = np.array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])</span>
<span class="sd">    &gt;&gt;&gt; result = cumsum(group_key, values, ngroups=2)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    [1. 3. 6. 4. 9. 15.]</span>

<span class="sd">    &gt;&gt;&gt; # With NaN values (skip_na=True)</span>
<span class="sd">    &gt;&gt;&gt; values_with_nan = np.array([1.0, np.nan, 3.0, 4.0, 5.0, np.nan])</span>
<span class="sd">    &gt;&gt;&gt; result = cumsum(group_key, values_with_nan, ngroups=2)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    [1. 1. 4. 4. 9. 9.]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_apply_cumulative</span><span class="p">(</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="o">**</span><span class="nb">locals</span><span class="p">())</span></div>



<div class="viewcode-block" id="cumcount">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.cumcount">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cumcount</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">],</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate cumulative count within each group.</span>

<span class="sd">    For each group defined by group_key, this function returns the running count</span>
<span class="sd">    of observations up to each position. The count resets at the beginning of</span>
<span class="sd">    each new group and starts from 0 (like pandas cumcount).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group_key : ArrayType1D</span>
<span class="sd">        1D array defining the groups</span>
<span class="sd">    ngroups : int</span>
<span class="sd">        Number of unique groups in group_key</span>
<span class="sd">    mask : Optional[ArrayType1D]</span>
<span class="sd">        Boolean mask to filter elements before counting</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Cumulative counts with same shape as input, dtype int64</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from groupby_lib.groupby.numba import cumcount</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Basic usage</span>
<span class="sd">    &gt;&gt;&gt; group_key = np.array([0, 0, 0, 1, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; result = cumcount(group_key, ngroups=2)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    [0 1 2 0 1 2]</span>

<span class="sd">    &gt;&gt;&gt; # With mask</span>
<span class="sd">    &gt;&gt;&gt; mask = np.array([True, False, True, True, True, False])</span>
<span class="sd">    &gt;&gt;&gt; result = cumcount(group_key, ngroups=2, mask=mask)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    [1 0 2 1 2 0]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">group_key</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">_apply_cumulative</span><span class="p">(</span>
            <span class="s2">&quot;count&quot;</span><span class="p">,</span>
            <span class="o">**</span><span class="nb">locals</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="o">-</span> <span class="mi">1</span>
    <span class="p">)</span>  <span class="c1"># Adjust to start from 0 like pandas</span></div>



<div class="viewcode-block" id="cummin">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.cummin">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cummin</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_na</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate cumulative minimum within each group.</span>

<span class="sd">    For each group defined by group_key, this function returns the running minimum</span>
<span class="sd">    of values up to each position. The cumulative minimum resets at the beginning</span>
<span class="sd">    of each new group.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group_key : ArrayType1D</span>
<span class="sd">        1D array defining the groups</span>
<span class="sd">    values : ArrayType1D</span>
<span class="sd">        Values to calculate cumulative minimum for</span>
<span class="sd">    ngroups : int</span>
<span class="sd">        Number of unique groups in group_key</span>
<span class="sd">    mask : Optional[ArrayType1D]</span>
<span class="sd">        Boolean mask to filter elements before aggregation</span>
<span class="sd">    skip_na : bool, default True</span>
<span class="sd">        Whether to skip NaN values in the minimum calculation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Cumulative minimums with same shape as input values</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from groupby_lib.groupby.numba import cummin</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Basic usage</span>
<span class="sd">    &gt;&gt;&gt; group_key = np.array([0, 0, 0, 1, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; values = np.array([3.0, 1.0, 4.0, 2.0, 5.0, 1.0])</span>
<span class="sd">    &gt;&gt;&gt; result = cummin(group_key, values, ngroups=2)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    [3. 1. 1. 2. 2. 1.]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_apply_cumulative</span><span class="p">(</span><span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="n">group_key</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">ngroups</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">skip_na</span><span class="p">)</span></div>



<div class="viewcode-block" id="cummax">
<a class="viewcode-back" href="../../../api_reference.html#groupby_lib.groupby.numba.cummax">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cummax</span><span class="p">(</span>
    <span class="n">group_key</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">ArrayType1D</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType1D</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_na</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate cumulative maximum within each group.</span>

<span class="sd">    For each group defined by group_key, this function returns the running maximum</span>
<span class="sd">    of values up to each position. The cumulative maximum resets at the beginning</span>
<span class="sd">    of each new group.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    group_key : ArrayType1D</span>
<span class="sd">        1D array defining the groups</span>
<span class="sd">    values : ArrayType1D</span>
<span class="sd">        Values to calculate cumulative maximum for</span>
<span class="sd">    ngroups : int</span>
<span class="sd">        Number of unique groups in group_key</span>
<span class="sd">    mask : Optional[ArrayType1D]</span>
<span class="sd">        Boolean mask to filter elements before aggregation</span>
<span class="sd">    skip_na : bool, default True</span>
<span class="sd">        Whether to skip NaN values in the maximum calculation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Cumulative maximums with same shape as input values</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from groupby_lib.groupby.numba import cummax</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Basic usage</span>
<span class="sd">    &gt;&gt;&gt; group_key = np.array([0, 0, 0, 1, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; values = np.array([1.0, 3.0, 2.0, 4.0, 1.0, 5.0])</span>
<span class="sd">    &gt;&gt;&gt; result = cummax(group_key, values, ngroups=2)</span>
<span class="sd">    &gt;&gt;&gt; print(result)</span>
<span class="sd">    [1. 3. 3. 4. 4. 5.]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_apply_cumulative</span><span class="p">(</span><span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="n">group_key</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">ngroups</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">skip_na</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Eoin Condron.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>